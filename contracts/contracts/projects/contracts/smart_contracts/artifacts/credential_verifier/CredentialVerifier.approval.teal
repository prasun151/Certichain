#pragma version 11
#pragma typetrack false

// algopy.arc4.ARC4Contract.approval_program() -> uint64:
main:
    intcblock 1 0 32 2
    bytecblock "authorized_institution"
    // smart_contracts/credential_verifier/contract.py:5
    // class CredentialVerifier(ARC4Contract):
    txn OnCompletion
    !
    assert
    txn ApplicationID
    bz main_create_NoOp@9
    pushbytess 0x388caffb 0x306a2f53 0x2eeebbb9 // method "issue_credential(address,string,string)uint64", method "verify_credential(uint64)string", method "get_contract_info()string"
    txna ApplicationArgs 0
    match issue_credential verify_credential main_get_contract_info_route@7
    err

main_get_contract_info_route@7:
    // smart_contracts/credential_verifier/contract.py:45
    // @abimethod(readonly=True)
    pushbytes 0x151f7c75002f43726564656e7469616c5665726966696572202d20416c676f72616e642043726564656e7469616c2053797374656d
    log
    intc_0 // 1
    return

main_create_NoOp@9:
    // smart_contracts/credential_verifier/contract.py:5
    // class CredentialVerifier(ARC4Contract):
    pushbytes 0xcc694eaa // method "create(address)void"
    txna ApplicationArgs 0
    match create
    err


// smart_contracts.credential_verifier.contract.CredentialVerifier.create[routing]() -> void:
create:
    // smart_contracts/credential_verifier/contract.py:11
    // @abimethod(create="require")
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    // smart_contracts/credential_verifier/contract.py:14
    // self.authorized_institution.value = institution
    bytec_0 // "authorized_institution"
    swap
    app_global_put
    // smart_contracts/credential_verifier/contract.py:11
    // @abimethod(create="require")
    intc_0 // 1
    return


// smart_contracts.credential_verifier.contract.CredentialVerifier.issue_credential[routing]() -> void:
issue_credential:
    // smart_contracts/credential_verifier/contract.py:16
    // @abimethod
    txna ApplicationArgs 1
    dup
    len
    intc_2 // 32
    ==
    assert // invalid number of bytes for arc4.static_array<arc4.uint8, 32>
    txna ApplicationArgs 2
    dup
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    txna ApplicationArgs 3
    dup
    intc_1 // 0
    extract_uint16 // on error: invalid array length header
    intc_3 // 2
    +
    dig 1
    len
    ==
    assert // invalid number of bytes for arc4.dynamic_array<arc4.uint8>
    extract 2 0
    // smart_contracts/credential_verifier/contract.py:25
    // assert Txn.sender == self.authorized_institution.value, "Only the authorized institution can issue credentials"
    txn Sender
    intc_1 // 0
    bytec_0 // "authorized_institution"
    app_global_get_ex
    assert // check self.authorized_institution exists
    ==
    assert // Only the authorized institution can issue credentials
    // smart_contracts/credential_verifier/contract.py:27-36
    // # Mint the NFT using an inner transaction
    // asset_create = itxn.AssetConfig(
    //     total=1,
    //     decimals=0,
    //     asset_name=credential_name,
    //     unit_name=String("CERT"),
    //     url=metadata_url,
    //     manager=Global.current_application_address,  # Contract is the manager
    //     reserve=student_address, # Reserve is the student
    // ).submit()
    itxn_begin
    // smart_contracts/credential_verifier/contract.py:34
    // manager=Global.current_application_address,  # Contract is the manager
    global CurrentApplicationAddress
    uncover 3
    itxn_field ConfigAssetReserve
    itxn_field ConfigAssetManager
    itxn_field ConfigAssetURL
    // smart_contracts/credential_verifier/contract.py:32
    // unit_name=String("CERT"),
    pushbytes "CERT"
    itxn_field ConfigAssetUnitName
    itxn_field ConfigAssetName
    // smart_contracts/credential_verifier/contract.py:30
    // decimals=0,
    intc_1 // 0
    itxn_field ConfigAssetDecimals
    // smart_contracts/credential_verifier/contract.py:29
    // total=1,
    intc_0 // 1
    itxn_field ConfigAssetTotal
    // smart_contracts/credential_verifier/contract.py:27-28
    // # Mint the NFT using an inner transaction
    // asset_create = itxn.AssetConfig(
    pushint 3 // acfg
    itxn_field TypeEnum
    intc_1 // 0
    itxn_field Fee
    // smart_contracts/credential_verifier/contract.py:27-36
    // # Mint the NFT using an inner transaction
    // asset_create = itxn.AssetConfig(
    //     total=1,
    //     decimals=0,
    //     asset_name=credential_name,
    //     unit_name=String("CERT"),
    //     url=metadata_url,
    //     manager=Global.current_application_address,  # Contract is the manager
    //     reserve=student_address, # Reserve is the student
    // ).submit()
    itxn_submit
    itxn CreatedAssetID
    // smart_contracts/credential_verifier/contract.py:16
    // @abimethod
    itob
    pushbytes 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return


// smart_contracts.credential_verifier.contract.CredentialVerifier.verify_credential[routing]() -> void:
verify_credential:
    // smart_contracts/credential_verifier/contract.py:40
    // @abimethod(readonly=True)
    txna ApplicationArgs 1
    len
    pushint 8
    ==
    assert // invalid number of bytes for arc4.uint64
    pushbytes 0x151f7c7500085665726966696564
    log
    intc_0 // 1
    return
